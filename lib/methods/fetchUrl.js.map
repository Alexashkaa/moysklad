{"version":3,"sources":["../../src/methods/fetchUrl.js"],"names":["have","require","getResponseError","errorsHttp","module","exports","uri","options","strict","arguments","url","includeHeaders","muteErrors","emit","emitter","bind","fetchOptions","headers","credentials","redirect","authHeader","getAuthHeader","Authorization","response","fetch","contentType","responseJson","error","has","get","indexOf","json","body","ok","status","toString","Error","statusText","fetchUrl"],"mappings":"AAAA;;;;;;AAEA,MAAMA,OAAOC,QAAQ,SAAR,CAAb;AACA,MAAMC,mBAAmBD,QAAQ,qBAAR,CAAzB;AACA,MAAME,aAAaF,QAAQ,eAAR,CAAnB;;AAEAG,OAAOC,OAAP;AAAA,+BAAiB,WAAyBC,GAAzB,EAA4C;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC3DP,SAAKQ,MAAL,CAAYC,SAAZ,EAAuB,EAAEC,KAAK,KAAP,EAAcH,SAAS,YAAvB,EAAvB;;AAEA;AACA,QAAII,iBAAiB,KAArB;AACA,QAAIC,aAAa,KAAjB;AACA,QAAIC,OAAO,KAAKC,OAAL,GAAe,KAAKA,OAAL,CAAaD,IAAb,CAAkBE,IAAlB,CAAuB,KAAKD,OAA5B,CAAf,GAAsD,IAAjE;;AAEA,QAAIE;AACFC,eAAS;AACP,wBAAgB;AADT,OADP;AAIFC,mBAAa,SAJX;AAKFC,gBAAU;AALR,OAMCZ,OAND,CAAJ;;AASA,QAAIS,aAAaL,cAAjB,EAAiC;AAC/BA,uBAAiB,IAAjB;AACA,aAAOK,aAAaL,cAApB;AACD;AACD,QAAIK,aAAaJ,UAAjB,EAA6B;AAC3BA,mBAAa,IAAb;AACA,aAAOI,aAAaJ,UAApB;AACD;;AAED,QAAIQ,aAAa,KAAKC,aAAL,EAAjB;AACA,QAAID,UAAJ,EAAgB;AACdJ,mBAAaC,OAAb,CAAqBK,aAArB,GAAqC,KAAKD,aAAL,EAArC;AACD;;AAED,QAAIR,IAAJ,EAAUA,KAAK,eAAL,EAAsB,EAAEP,QAAF,EAAOC,SAASS,YAAhB,EAAtB;AACV;AACA,QAAIO,WAAW,MAAM,KAAKC,KAAL,CAAWlB,GAAX,EAAgBU,YAAhB,CAArB;;AAEA,QAAIS,WAAJ,EAAiBC,YAAjB,EAA+BC,KAA/B;;AAEA,QAAId,IAAJ,EAAUA,KAAK,eAAL,EAAsB,EAAEP,QAAF,EAAOC,SAASS,YAAhB,EAA8BO,kBAA9B,EAAtB;AACV,QAAIA,SAASN,OAAT,CAAiBW,GAAjB,CAAqB,cAArB,CAAJ,EAA0C;AACxCH,oBAAcF,SAASN,OAAT,CAAiBY,GAAjB,CAAqB,cAArB,CAAd;AACD;;AAED,QAAIJ,eAAeA,YAAYK,OAAZ,CAAoB,kBAApB,MAA4C,CAAC,CAAhE,EAAmE;AACjE;AACAJ,qBAAe,MAAMH,SAASQ,IAAT,EAArB;AACA,UAAIlB,IAAJ,EAAUA,KAAK,eAAL,EAAsB,EAAEP,QAAF,EAAOC,SAASS,YAAhB,EAA8BO,kBAA9B,EAAwCS,MAAMN,YAA9C,EAAtB;AACVC,cAAQzB,iBAAiBwB,YAAjB,CAAR;AACD,KALD,MAKO,IAAI,CAACH,SAASU,EAAd,EAAkB;AACvB;AACAN,cAAQxB,WAAWoB,SAASW,MAAT,CAAgBC,QAAhB,EAAX,CAAR;AACAR,cAAQ,IAAIS,KAAJ,CAAUT,SAAU,eAAcJ,SAASW,MAAO,IAAGX,SAASc,UAAW,EAAzE,CAAR;AACD;;AAED,QAAIV,KAAJ,EAAW;AACT,UAAId,IAAJ,EAAUA,KAAK,OAAL,EAAcc,KAAd;AACV,UAAI,CAACf,UAAL,EAAiB,MAAMe,KAAN;AAClB;;AAED,WAAOhB,iBAAiB,CAACY,SAASN,OAAV,EAAmBS,YAAnB,EAAiCH,QAAjC,CAAjB,GAA8DG,YAArE;AACD,GA3DD;;AAAA,WAAgCY,QAAhC;AAAA;AAAA;;AAAA,SAAgCA,QAAhC;AAAA","file":"fetchUrl.js","sourcesContent":["'use strict'\n\nconst have = require('../have')\nconst getResponseError = require('../getResponseError')\nconst errorsHttp = require('../errorsHttp')\n\nmodule.exports = async function fetchUrl (uri, options = {}) {\n  have.strict(arguments, { url: 'url', options: 'opt Object' })\n\n  // Специфические параметры (не передаются в опции fetch)\n  let includeHeaders = false\n  let muteErrors = false\n  let emit = this.emitter ? this.emitter.emit.bind(this.emitter) : null\n\n  let fetchOptions = {\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    credentials: 'include',\n    redirect: 'manual',\n    ...options\n  }\n\n  if (fetchOptions.includeHeaders) {\n    includeHeaders = true\n    delete fetchOptions.includeHeaders\n  }\n  if (fetchOptions.muteErrors) {\n    muteErrors = true\n    delete fetchOptions.muteErrors\n  }\n\n  let authHeader = this.getAuthHeader()\n  if (authHeader) {\n    fetchOptions.headers.Authorization = this.getAuthHeader()\n  }\n\n  if (emit) emit('request:start', { uri, options: fetchOptions })\n  /** @type {Response} */\n  let response = await this.fetch(uri, fetchOptions)\n\n  let contentType, responseJson, error\n\n  if (emit) emit('response:head', { uri, options: fetchOptions, response })\n  if (response.headers.has('Content-Type')) {\n    contentType = response.headers.get('Content-Type')\n  }\n\n  if (contentType && contentType.indexOf('application/json') !== -1) {\n    // получение ответа сервера и обработка ошибок API\n    responseJson = await response.json()\n    if (emit) emit('response:body', { uri, options: fetchOptions, response, body: responseJson })\n    error = getResponseError(responseJson)\n  } else if (!response.ok) {\n    // обработка ошибок http\n    error = errorsHttp[response.status.toString()]\n    error = new Error(error || `Http error: ${response.status} ${response.statusText}`)\n  }\n\n  if (error) {\n    if (emit) emit('error', error)\n    if (!muteErrors) throw error\n  }\n\n  return includeHeaders ? [response.headers, responseJson, response] : responseJson\n}\n"]}