{"version":3,"sources":["../../src/methods/fetchUri.js"],"names":["have","require","getResponseError","errorsHttp","module","exports","uri","options","strict","arguments","includeHeaders","muteErrors","emit","emitter","bind","fetchOptions","Object","assign","headers","credentials","redirect","authHeader","getAuthHeader","Authorization","response","fetch","contentType","responseJson","error","has","get","indexOf","json","body","ok","status","toString","Error","statusText","fetchUri"],"mappings":"AAAA;;;;AAEA,MAAMA,OAAOC,QAAQ,SAAR,CAAb;AACA,MAAMC,mBAAmBD,QAAQ,qBAAR,CAAzB;AACA,MAAME,aAAaF,QAAQ,eAAR,CAAnB;;AAEAG,OAAOC,OAAP;AAAA,+BAAiB,WAAyBC,GAAzB,EAA4C;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC3DP,SAAKQ,MAAL,CAAYC,SAAZ,EAAuB,EAAEH,KAAK,KAAP,EAAcC,SAAS,YAAvB,EAAvB;;AAEA;AACA,QAAIG,iBAAiB,KAArB;AACA,QAAIC,aAAa,KAAjB;AACA,QAAIC,OAAO,KAAKC,OAAL,GAAe,KAAKA,OAAL,CAAaD,IAAb,CAAkBE,IAAlB,CAAuB,KAAKD,OAA5B,CAAf,GAAsD,IAAjE;;AAEA,QAAIE,eAAeC,OAAOC,MAAP,CAAc,EAAd,EAAkB;AACnCC,eAAS;AACP,wBAAgB;AADT,OAD0B;AAInCC,mBAAa,SAJsB;AAKnCC,gBAAU;AALyB,KAAlB,EAMhBb,OANgB,CAAnB;;AAQA,QAAIQ,aAAaL,cAAjB,EAAiC;AAC/BA,uBAAiB,IAAjB;AACA,aAAOK,aAAaL,cAApB;AACD;AACD,QAAIK,aAAaJ,UAAjB,EAA6B;AAC3BA,mBAAa,IAAb;AACA,aAAOI,aAAaJ,UAApB;AACD;;AAED,QAAIU,aAAa,KAAKC,aAAL,EAAjB;AACA,QAAID,UAAJ,EAAgB;AACdN,mBAAaG,OAAb,CAAqBK,aAArB,GAAqC,KAAKD,aAAL,EAArC;AACD;;AAED,QAAIV,IAAJ,EAAUA,KAAK,eAAL,EAAsB,EAAEN,QAAF,EAAOC,SAASQ,YAAhB,EAAtB;AACV;AACA,QAAIS,WAAW,MAAM,KAAKC,KAAL,CAAWnB,GAAX,EAAgBS,YAAhB,CAArB;;AAEA,QAAIW,WAAJ,EAAiBC,YAAjB,EAA+BC,KAA/B;;AAEA,QAAIhB,IAAJ,EAAUA,KAAK,eAAL,EAAsB,EAAEN,QAAF,EAAOC,SAASQ,YAAhB,EAA8BS,kBAA9B,EAAtB;AACV,QAAIA,SAASN,OAAT,CAAiBW,GAAjB,CAAqB,cAArB,CAAJ,EAA0C;AACxCH,oBAAcF,SAASN,OAAT,CAAiBY,GAAjB,CAAqB,cAArB,CAAd;AACD;;AAED,QAAIJ,eAAeA,YAAYK,OAAZ,CAAoB,kBAApB,MAA4C,CAAC,CAAhE,EAAmE;AACjE;AACAJ,qBAAe,MAAMH,SAASQ,IAAT,EAArB;AACA,UAAIpB,IAAJ,EAAUA,KAAK,eAAL,EAAsB,EAAEN,QAAF,EAAOC,SAASQ,YAAhB,EAA8BS,kBAA9B,EAAwCS,MAAMN,YAA9C,EAAtB;AACVC,cAAQ1B,iBAAiByB,YAAjB,CAAR;AACD,KALD,MAKO,IAAI,CAACH,SAASU,EAAd,EAAkB;AACvB;AACAN,cAAQzB,WAAWqB,SAASW,MAAT,CAAgBC,QAAhB,EAAX,CAAR;AACAR,cAAQ,IAAIS,KAAJ,CAAUT,SAAU,eAAcJ,SAASW,MAAO,IAAGX,SAASc,UAAW,EAAzE,CAAR;AACD;;AAED,QAAIV,KAAJ,EAAW;AACT,UAAIhB,IAAJ,EAAUA,KAAK,OAAL,EAAcgB,KAAd;AACV,UAAI,CAACjB,UAAL,EAAiB,MAAMiB,KAAN;AAClB;;AAED,WAAOlB,iBAAiB,CAACc,SAASN,OAAV,EAAmBS,YAAnB,EAAiCH,QAAjC,CAAjB,GAA8DG,YAArE;AACD,GA1DD;;AAAA,WAAgCY,QAAhC;AAAA;AAAA;;AAAA,SAAgCA,QAAhC;AAAA","file":"fetchUri.js","sourcesContent":["'use strict'\n\nconst have = require('../have')\nconst getResponseError = require('../getResponseError')\nconst errorsHttp = require('../errorsHttp')\n\nmodule.exports = async function fetchUri (uri, options = {}) {\n  have.strict(arguments, { uri: 'str', options: 'opt Object' })\n\n  // Специфические параметры (не передаются в опции fetch)\n  let includeHeaders = false\n  let muteErrors = false\n  let emit = this.emitter ? this.emitter.emit.bind(this.emitter) : null\n\n  let fetchOptions = Object.assign({}, {\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    credentials: 'include',\n    redirect: 'manual'\n  }, options)\n\n  if (fetchOptions.includeHeaders) {\n    includeHeaders = true\n    delete fetchOptions.includeHeaders\n  }\n  if (fetchOptions.muteErrors) {\n    muteErrors = true\n    delete fetchOptions.muteErrors\n  }\n\n  let authHeader = this.getAuthHeader()\n  if (authHeader) {\n    fetchOptions.headers.Authorization = this.getAuthHeader()\n  }\n\n  if (emit) emit('request:start', { uri, options: fetchOptions })\n  /** @type {Response} */\n  let response = await this.fetch(uri, fetchOptions)\n\n  let contentType, responseJson, error\n\n  if (emit) emit('response:head', { uri, options: fetchOptions, response })\n  if (response.headers.has('Content-Type')) {\n    contentType = response.headers.get('Content-Type')\n  }\n\n  if (contentType && contentType.indexOf('application/json') !== -1) {\n    // получение ответа сервера и обработка ошибок API\n    responseJson = await response.json()\n    if (emit) emit('response:body', { uri, options: fetchOptions, response, body: responseJson })\n    error = getResponseError(responseJson)\n  } else if (!response.ok) {\n    // обработка ошибок http\n    error = errorsHttp[response.status.toString()]\n    error = new Error(error || `Http error: ${response.status} ${response.statusText}`)\n  }\n\n  if (error) {\n    if (emit) emit('error', error)\n    if (!muteErrors) throw error\n  }\n\n  return includeHeaders ? [response.headers, responseJson, response] : responseJson\n}\n"]}